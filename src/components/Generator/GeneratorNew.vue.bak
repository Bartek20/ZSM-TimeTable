<script setup>
	const active = ref(false);

	const toggleActive = () => {
		active.value = !active.value;
	};
	const files = ref({});
	const parsable = ref({});
	async function readFile(file) {
		try {
			const reader = new FileReader();
			return await new Promise((resolve) => {
				reader.onloadend = (data) => resolve(data.target.result);
				reader.readAsText(file);
			});
		} catch (err) {
			console.log(err);
		}
	}
	async function getAllFileEntries(dataTransferItemList) {
		let fileEntries = [];
		let queue = [];
		for (let i = 0; i < dataTransferItemList.length; i++) {
			queue.push(dataTransferItemList[i].webkitGetAsEntry());
		}
		while (queue.length > 0) {
			let entry = queue.shift();
			if (entry.isFile) {
				fileEntries.push(await readFileObject(entry));
			} else if (entry.isDirectory) {
				queue.push(...(await readAllDirectoryEntries(entry.createReader())));
			}
		}
		return fileEntries;
	}
	async function readAllDirectoryEntries(directoryReader) {
		let entries = [];
		let readEntries = await readEntriesPromise(directoryReader);
		while (readEntries.length > 0) {
			entries.push(...readEntries);
			readEntries = await readEntriesPromise(directoryReader);
		}
		return entries;
	}
	async function readEntriesPromise(directoryReader) {
		try {
			return await new Promise((resolve, reject) => {
				directoryReader.readEntries(resolve, reject);
			});
		} catch (err) {
			console.log(err);
		}
	}
	async function readFileObject(fileEntry) {
		try {
			return await new Promise((resolve, reject) => {
				fileEntry.file(resolve, reject);
			});
		} catch (err) {
			console.log(err);
		}
	}

	const drop = async (e) => {
		const fs = await getAllFileEntries(e.dataTransfer.items);
		var out = {
			files: {},
			parsable: {},
		};
		for (let i = 0; i < fs.length; i++) {
			const file = fs[i];
			out.files[file.name] = file;
			if (file.name.endsWith('.html')) {
				out.parsable[file.name] = await readFile(file);
			}
		}
		files.value = out.files;
		parsable.value = out.parsable;
	};

	const selectedFile = async () => {
		const fs = [...document.querySelector('.dropzoneFile').files];
		var out = {
			files: {},
			parsable: {},
		};
		for (let i = 0; i < fs.length; i++) {
			const file = fs[i];
			out.files[file.name] = file;
			if (file.name.endsWith('.html')) {
				out.parsable[file.name] = await readFile(file);
			}
		}
		files.value = out.files;
		parsable.value = out.parsable;
	};
	function dropped(e) {
		toggleActive();
		drop(e);
	}
</script>

<template>
	<div class="home">
		<h1>DropZone</h1>
		<div
			@dragenter.prevent="toggleActive"
			@dragleave.prevent="toggleActive"
			@dragover.prevent
			@drop.prevent="dropped"
			:class="{ 'active-dropzone': active }"
			class="dropzone">
			<span>Drag or Drop File</span>
			<span>OR</span>
			<label for="dropzoneFile">Select File</label>
			<input
				@change="selectedFile"
				type="file"
				id="dropzoneFile"
				class="dropzoneFile"
				directory
				webkitdirectory
				mozdirectory />
		</div>
		<span v-for="(file, index) in files" class="file-info"
			>File: {{ index }}</span
		>
	</div>
</template>

<style lang="scss" scoped>
	.home {
		height: 100vh;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		background-color: #f1f1f1;

		h1 {
			font-size: 40px;
			margin-bottom: 32px;
		}

		.file-info {
			margin-top: 32px;
		}
	}
	.dropzone {
		width: 400px;
		height: 200px;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		row-gap: 16px;
		border: 2px dashed #41b883;
		background-color: #fff;
		transition: 0.3s ease all;

		label {
			padding: 8px 12px;
			color: #fff;
			background-color: #41b883;
			transition: 0.3s ease all;
		}

		input {
			display: none;
		}
	}

	.active-dropzone {
		color: #fff;
		border-color: #fff;
		background-color: #41b883;

		label {
			background-color: #fff;
			color: #41b883;
		}
	}
</style>
